#include <nds.h>

#include <stdio.h>

#include<gl2d.h>

#include<string>

#include <list>

#include <cmath>

#include "shuttle.h"

#include "area_1_button.h"

#include "area_2_button.h"

#include "area_3_button.h"

#include "area_selector.h"

#include "background_main_menu.h"

#include "projectile.h"

#include "slime_sprite.h"

#include "area_1_bg.h"

#include "platform_type_1.h"

#include "player_character.h"

#include "ammo_counter.h"

#include "uvcoord_player_character.h"

#include "uvcoord_ammo_counter.h"


using namespace std;

volatile int frame = 0;

glImage Area_1_Button[1];

glImage Area_2_Button[1];

glImage Area_3_Button[1];

glImage Background_Main_Menu[1];

glImage Area_Selector[1];

glImage Projectile_Sprite[1];

glImage Slime_Sprite[1];

glImage Area_1_BG[1];

glImage Platform_Type_1[1];

glImage Player_Character[PLAYER_CHARACTER_NUM_IMAGES];

glImage Ammo_Counter[AMMO_COUNTER_NUM_IMAGES];


//256x192 pixels

//---------------------------------------LoadSprites class----------------------------------------//

class LoadSprites{

    private:

        int Area_1_ButtonSpriteID;
        int Area_2_ButtonSpriteID;
        int Area_3_ButtonSpriteID;
        int Background_Main_MenuID;
        int Area_SelectorID;
        int ProjectileID;
        int Slime_SpriteID;
        int Area_1_BGID;
        int Platform_Type_1ID;
        int Player_CharacterID;
        int Ammo_CounterID;


    public:

        LoadSprites(){

            int Area_1_ButtonSpriteID = 
                glLoadTileSet( Area_1_Button,			// pointer to glImage array
                            64,				// sprite width
                            16,				// sprite height
                            64,				// bitmap image width
                            16,				// bitmap image height
                            GL_RGB16,		// texture type for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_64,	// sizeX for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_16,	// sizeY for glTexImage2D() in videoGL.h
                            GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT,
                            16,					// Length of the palette to use (16 colors)
                            (u16*)area_1_buttonPal,	// Load our 16 color Shuttle palette
                            (u8*)area_1_buttonBitmap  // image data generated by GRIT
                            );

            int Area_2_ButtonSpriteID = 
                glLoadTileSet( Area_2_Button,			// pointer to glImage array
                            64,				// sprite width
                            16,				// sprite height
                            64,				// bitmap image width
                            16,				// bitmap image height
                            GL_RGB16,		// texture type for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_64,	// sizeX for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_16,	// sizeY for glTexImage2D() in videoGL.h
                            GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT,
                            16,					// Length of the palette to use (16 colors)
                            (u16*)area_2_buttonPal,	// Load our 16 color Shuttle palette
                            (u8*)area_2_buttonBitmap  // image data generated by GRIT
                            );




            int Area_3_ButtonSpriteID = 
                glLoadTileSet( Area_3_Button,			// pointer to glImage array
                            64,				// sprite width
                            16,				// sprite height
                            64,				// bitmap image width
                            16,				// bitmap image height
                            GL_RGB16,		// texture type for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_64,	// sizeX for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_16,	// sizeY for glTexImage2D() in videoGL.h
                            GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT,
                            16,					// Length of the palette to use (16 colors)
                            (u16*)area_3_buttonPal,	// Load our 16 color Shuttle palette
                            (u8*)area_3_buttonBitmap  // image data generated by GRIT
                            );


            int Background_Main_MenuID = 
                glLoadTileSet( Background_Main_Menu,			// pointer to glImage array
                            256,				// sprite width
                            256,				// sprite height
                            256,				// bitmap image width
                            256,				// bitmap image height
                            GL_RGB16,		// texture type for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_256,	// sizeX for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_256,	// sizeY for glTexImage2D() in videoGL.h
                            GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT,
                            16,					// Length of the palette to use (16 colors)
                            (u16*)background_main_menuPal,	// Load our 16 color Shuttle palette
                            (u8*)background_main_menuBitmap  // image data generated by GRIT
                            );

            int Area_SelectorID = 
                glLoadTileSet( Area_Selector,			// pointer to glImage array
                            64,				// sprite width
                            16,				// sprite height
                            64,				// bitmap image width
                            16,				// bitmap image height
                            GL_RGB16,		// texture type for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_64,	// sizeX for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_16,	// sizeY for glTexImage2D() in videoGL.h
                            GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT,
                            16,					// Length of the palette to use (16 colors)
                            (u16*)area_selectorPal,	// Load our 16 color Shuttle palette
                            (u8*)area_selectorBitmap  // image data generated by GRIT
                            );


            int ProjectileID = 
                glLoadTileSet( Projectile_Sprite,			// pointer to glImage array
                            8,				// sprite width
                            8,				// sprite height
                            8,				// bitmap image width
                            8,				// bitmap image height
                            GL_RGB16,		// texture type for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_8,	// sizeX for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_8,	// sizeY for glTexImage2D() in videoGL.h
                            GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT,
                            16,					// Length of the palette to use (16 colors)
                            (u16*)projectilePal,	// Load our 16 color Shuttle palette
                            (u8*)projectileBitmap  // image data generated by GRIT
                            );


            int Slime_SpriteID = 
                glLoadTileSet( Slime_Sprite,			// pointer to glImage array
                            16,				// sprite width
                            16,				// sprite height
                            16,				// bitmap image width
                            16,				// bitmap image height
                            GL_RGB16,		// texture type for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_16,	// sizeX for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_16,	// sizeY for glTexImage2D() in videoGL.h
                            GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT,
                            16,					// Length of the palette to use (16 colors)
                            (u16*)slime_spritePal,	// Load our 16 color Shuttle palette
                            (u8*)slime_spriteBitmap  // image data generated by GRIT
                            );


            int Area_1_BGID = 
                glLoadTileSet( Area_1_BG,			// pointer to glImage array
                            256,				// sprite width
                            256,				// sprite height
                            256,				// bitmap image width
                            256,				// bitmap image height
                            GL_RGB16,		// texture type for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_256,	// sizeX for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_256,	// sizeY for glTexImage2D() in videoGL.h
                            GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT,
                            16,					// Length of the palette to use (16 colors)
                            (u16*)area_1_bgPal,	// Load our 16 color Shuttle palette
                            (u8*)area_1_bgBitmap  // image data generated by GRIT
                            );



            int Platform_Type_1ID = 
                glLoadTileSet( Platform_Type_1,			// pointer to glImage array
                            32,				// sprite width
                            8,				// sprite height
                            32,				// bitmap image width
                            8,				// bitmap image height
                            GL_RGB16,		// texture type for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_32,	// sizeX for glTexImage2D() in videoGL.h
                            TEXTURE_SIZE_8,	// sizeY for glTexImage2D() in videoGL.h
                            GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT,
                            16,					// Length of the palette to use (16 colors)
                            (u16*)platform_type_1Pal,	// Load our 16 color Shuttle palette
                            (u8*)platform_type_1Bitmap  // image data generated by GRIT
                            );

            int Player_CharacterID = 
                glLoadSpriteSet( Player_Character,					// pointer to glImage array
                                PLAYER_CHARACTER_NUM_IMAGES, 		// Texture packer auto-generated #define
                                player_character_texcoords,		// Texture packer auto-generated array
                                GL_RGB16,				// texture type for glTexImage2D() in videoGL.h 
                                TEXTURE_SIZE_128,		// sizeX for glTexImage2D() in videoGL.h
                                TEXTURE_SIZE_1024,		// sizeY for glTexImage2D() in videoGL.h
                                GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
                                16,					// Length of the palette to use (256 colors)
                                (u16*)player_characterPal,		
                                (u8*)player_characterBitmap	 	// image data generated by GRIT
                            );

            int Ammo_CounterID = 
                glLoadSpriteSet( Ammo_Counter,					// pointer to glImage array
                                AMMO_COUNTER_NUM_IMAGES, 		// Texture packer auto-generated #define
                                ammo_counter_texcoords,		// Texture packer auto-generated array
                                GL_RGB16,				// texture type for glTexImage2D() in videoGL.h 
                                TEXTURE_SIZE_128,		// sizeX for glTexImage2D() in videoGL.h
                                TEXTURE_SIZE_128,		// sizeY for glTexImage2D() in videoGL.h
                                GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
                                16,					// Length of the palette to use (256 colors)
                                (u16*)ammo_counterPal,		
                                (u8*)ammo_counterBitmap	 	// image data generated by GRIT
                            );


        }




};


//----------------------------------------player class----------------------------------------//


class Player{

    private:

        int GRAVITY = 10;
        int velocity = 0;
        int velocity_increment = 1;
        bool moving_right = false;
        bool moving_left = false;
        bool jumping = false;
        bool falling = false;
        int x_position_centre;
        int y_position_centre;
        int x_position_left;
        int x_position_right;
        int y_position_top;
        int y_position_bottom;
        bool on_platform = true;
        char direction_facing;
        int hitbox_width = 7;
        int hitbox_height = 16;
        int sprite_frame = 5;
        int sprite_display_x;
        int sprite_display_y;
        int spritesheet_section = 0;
        int frame_cap;
        int player_speed = 4;


    public:

        Player(int x, int y, char facing){

            this->x_position_centre = x;
            this->x_position_left = x_position_centre - hitbox_width;
            this->x_position_right = x_position_centre + hitbox_width;
            

            this->y_position_centre = y;
            this->y_position_top = y_position_centre - 16;
            this->y_position_bottom = y_position_centre + 16;
            this->sprite_display_y = y_position_centre - 16;

            this->direction_facing = facing;

            if (direction_facing == 'r'){
                this->frame_cap = 4;
                this->sprite_display_x = x_position_centre - hitbox_width - 3;
            }
            else{
                this->frame_cap = 9;
                this->sprite_display_x = x_position_centre - hitbox_width - 10;
            }
            

        }

        int get_hitbox_width(){
            return hitbox_width;
        }

        bool get_falling(){
            return falling;
        }

        int get_y_position_top(){
            return y_position_top;
        }

        int get_y_position_bottom(){
            return y_position_bottom;
        }

        int get_x_position_left(){
            return x_position_left;
        }

        int get_x_position_right(){
            return x_position_right;
        }

        int get_centre_x(){
            return x_position_centre;
        }

        int get_centre_y(){
            return y_position_centre;
        }

        bool get_jumping(){
            return jumping;
        }

        bool get_moving_left(){
            return moving_left;
        }

        bool get_moving_right(){
            return moving_right;
        }

        bool get_direction_facing(){
            return direction_facing;
        }

        void display_position(){

            glBegin2D();/*opens gl for 2d creation*/

            glSprite(sprite_display_x, sprite_display_y,GL_FLIP_NONE,&Player_Character[sprite_frame]);

            glEnd2D();/*ends gl for 2d creation*/

        }

        void set_sprite_frame(int new_value){
            sprite_frame = new_value;
        }

        void set_all_y(int new_value){

            y_position_centre = new_value;
            y_position_top = new_value-hitbox_height;
            y_position_bottom = new_value+hitbox_height;
            sprite_display_y = new_value-hitbox_height;
            

        }

        void set_falling(bool new_value){
            falling = new_value;
        }

        void set_all_x(int new_value){
            x_position_centre = new_value;
            x_position_left = new_value-hitbox_width;
            x_position_right = new_value+hitbox_width;
            if (direction_facing == 'r'){
                sprite_display_x = new_value-hitbox_width - 3;
            }
            else{
                sprite_display_x = new_value-hitbox_width - 10;
            }
            
        }

         void update_jump_action(){
            if ((falling == false) && (jumping == false)){
                //only jump when not falling or jumping
                jumping = true;
                velocity = GRAVITY;

            }
        }

        void update_move_right_action(bool new_value){

            if(moving_left==false){
                moving_right = new_value;
                direction_facing = 'r';

            }    
        }

        void update_move_left_action(bool new_value){

            if(moving_right==false){
                moving_left = new_value;
                direction_facing = 'l';
            }
        }

        void character_movement(){

            if(moving_left == true){
                set_all_x(x_position_centre-player_speed);
            }

            if(moving_right == true){
                set_all_x(x_position_centre+player_speed);
            }

            if (jumping == true){
                set_all_y(y_position_centre-velocity);
                velocity -= velocity_increment;
                //if jump hits peak then it is falling
                if (velocity == 0){
                    jumping = false;
                    falling = true;
                }
            }

            if (falling == true){
                set_all_y(y_position_centre-velocity);
                velocity -= velocity_increment;
            }
        }

        void sprite_frame_update(){

            sprite_frame += 1;
            

            if ((moving_right == false) & (moving_left == false) & (direction_facing == 'r')){
                //start idle right
                frame_cap = 4;
                spritesheet_section = 0;
                sprite_display_x = x_position_centre - hitbox_width - 3;
            }
            
            if ((moving_right == false) & (moving_left == false) & (direction_facing == 'l')){
                //start idle left
                frame_cap = 9;
                spritesheet_section = 1;
                sprite_display_x = x_position_centre - hitbox_width - 10;
            }

            if ((moving_right == true) & (moving_left == false)){
                //start moving right
                frame_cap = 15;
                spritesheet_section = 2;
            }

            if ((moving_right == false) & (moving_left == true)){
                //start moving left
                frame_cap = 21;
                spritesheet_section = 3;
            }

            if (spritesheet_section == 0){
                if (sprite_frame > frame_cap){
                    sprite_frame = 0;
                }
            }

            if (spritesheet_section == 1){
                if (sprite_frame > frame_cap){
                    sprite_frame = 5;
                }
                
            }
            
            if (spritesheet_section == 2){
                if (sprite_frame > frame_cap){
                    sprite_frame = 10;
                }
                
            }

            if (spritesheet_section == 3){
                if (sprite_frame > frame_cap){
                    sprite_frame = 16;
                }
                
            }

            
            iprintf("sprite frame %i",sprite_frame);
            iprintf("\n");
            iprintf("moving_left %i",moving_left);
            iprintf("\n");
            iprintf("moving right %i",moving_right);
            iprintf("\n");
            iprintf("spritesheet section %i",spritesheet_section);
            iprintf("\n");
            //consoleClear();


        }


};



//----------------------------------------projectile class----------------------------------------//


class Projectile{

    private:

    int projectile_speed;
    char direction_facing;
    int x_position_centre;
    int x_position_left;
    int x_position_right;
    int y_position_centre;
    int y_position_top;
    int y_position_bottom;
    int damage;
    int width;
    int height;
    bool exist = true;



    public:

    Projectile(int projectile_speed, char direction_facing, int x_position_centre, int y_position_centre, int width, int height, int damage){

        if(direction_facing == 'r'){
            this->projectile_speed = projectile_speed;
        }
        else{
            this->projectile_speed = -(projectile_speed);
        }
        
        this->direction_facing = direction_facing;
        this->x_position_centre = x_position_centre;
        this->x_position_left = x_position_centre - (width/2);
        this->x_position_right = x_position_centre + (width/2);

        this->y_position_centre = y_position_centre;
        this->y_position_top = y_position_centre - (height/2);
        this->y_position_bottom = y_position_centre + (height/2);

        this->damage = damage;

    }


    void display_projectile(){

        glBegin2D();/*opens gl for 2d creation*/

        glSprite(x_position_left, y_position_top,GL_FLIP_NONE,Projectile_Sprite);

        glEnd2D();/*ends gl for 2d creation*/

    }


    void update_position(){

        x_position_centre += projectile_speed;
        x_position_left = x_position_centre - (width/2);
        x_position_right = x_position_centre + (width/2);

        if ((x_position_centre > 256)|(x_position_centre < 0)){
            exist = false;
        } 

    }

    int get_x_position_centre(){
        return x_position_centre;
    }

    int get_x_position_left(){
        return x_position_left;
    }

    int get_x_position_right(){
        return x_position_right;
    }

    int get_y_position_centre(){
        return y_position_centre;
    }

    int get_y_position_top(){
        return y_position_top;
    }

    int get_y_position_bottom(){
        return y_position_bottom;
    }

    int get_projectile_speed(){
        return projectile_speed;
    }

    bool get_exist(){
        return exist;
    }

    int get_damage(){
        return damage;
    }

    void set_exist(bool new_value){
        exist = new_value;
    }


};


//----------------------------------------ranged weapon class----------------------------------------//

class Weapon{

    private:

        //times are frame based

        int projectile_speed;
        int damage;
        int projectile_delay;
        int reload_time;
        int time_until_next_projectile = 0;
        bool reloading = false;
        int projectile_capacity;
        int x_position_centre;
        int y_position_centre;
        int current_projectile_amount;
        string weapon_type;
        char direction_facing;
        int time_until_reloaded;
        int ammo_counter_sprite = 0;


    public:

        Weapon(int projectile_speed, int damage, int projectile_delay, int reload_time, int direction_facing,
         int projectile_capacity, int x_position_centre, int y_position_centre, string weapon_type){

            this->projectile_speed = projectile_speed;
            this->damage = damage;
            this->projectile_delay = projectile_delay;
            this->reload_time = reload_time;
            this->direction_facing = direction_facing;
            this->projectile_capacity = projectile_capacity;
            this->current_projectile_amount = projectile_capacity;

            this->x_position_centre = x_position_centre;
            this->y_position_centre = y_position_centre;

            this->weapon_type = weapon_type;

        }

        int get_time_until_next_projectile(){
            return time_until_next_projectile;
        }

        int get_time_until_reloaded(){
            return time_until_reloaded;
        }

        int get_current_projectile_amount(){
            return current_projectile_amount;
        }

        bool get_reloading(){
            return reloading;
        }

        void set_damage(int new_value){
            damage = new_value;
        }

        void update_time_until_reloaded(int new_time){
            time_until_reloaded = new_time;
        }

        void update_time_until_next_projectile(int new_time){
            time_until_next_projectile = new_time;
        }

        void move_weapon(int new_x, int new_y){

            if (new_x != x_position_centre){

                if(new_x > x_position_centre){
                    direction_facing = 'r';
                }
                
                else{
                    direction_facing = 'l';
                }
            }
            
            x_position_centre = new_x;
            
            y_position_centre = new_y;

        }

        void start_reload_timer(){
            reloading = true;
            time_until_reloaded = reload_time;
        }

        void reload_magazine(){
            ammo_counter_sprite = 0;
            current_projectile_amount = projectile_capacity;
            reloading = false;
        }

        bool shoot_projectile(){

            bool shooting = false;

            if ((time_until_next_projectile == 0)&(current_projectile_amount > 0)&(reloading == false)){
                time_until_next_projectile = projectile_delay;
                current_projectile_amount -= 1;
                ammo_counter_sprite += 1;
                shooting = true;
            }

            return shooting;

        }


        void display_ammo_counter(){

            glBegin2D();
            glSprite(8, 8,GL_FLIP_NONE,&Ammo_Counter[ammo_counter_sprite]);
            glEnd2D();

        }


        Projectile* create_projectile(){

            if(direction_facing == 'r'){
                Projectile *new_projectile = new Projectile(projectile_speed,direction_facing, x_position_centre+24,y_position_centre-1,10,5,damage);
                return new_projectile;
            }
            else{
                Projectile *new_projectile = new Projectile(projectile_speed,direction_facing, x_position_centre-20,y_position_centre-1,10,5,damage);
                return new_projectile;
            }

        }

};

//----------------------------------------platform class----------------------------------------//

class Platform{

    private:

        int x_position_centre;
        int y_position_centre;
        int x_position_left;
        int x_position_right;
        int y_position_top;
        int y_position_bottom;

    public:

    Platform(int x_centre, int y_centre, int width, int height){
        this->x_position_centre = x_centre;
        this->x_position_left = x_position_centre-(width/2);
        this->x_position_right = x_position_centre+(width/2);

        this->y_position_centre = y_centre;
        this->y_position_top = y_position_centre-(height/2);
        this->y_position_bottom = y_position_centre+(height/2);
    }

    bool detect_collision_player(Player player){
        bool contact = false;
        // if player's bottom is inside platform
        if ((player.get_x_position_left()<x_position_right)
            &(player.get_x_position_right()>x_position_left)
            &(player.get_y_position_bottom()>y_position_top)
            &(player.get_y_position_bottom()<y_position_bottom)){
                contact = true;
            }
        
        return contact;
    }

    int get_y_position_top(){
        return y_position_top;
    }

    int get_y_position_bottom(){
        return y_position_bottom;
    }

    int get_x_position_left(){
        return x_position_left;
    }

    int get_x_position_right(){
        return x_position_right;
    }

    void display_position(){

        glBegin2D();/*opens gl for 2d creation*/

        glSprite(x_position_left, y_position_top,GL_FLIP_NONE,Platform_Type_1);

        glEnd2D();/*ends gl for 2d creation*/

    }

};


//----------------------------------------cursor class----------------------------------------//


class Cursor{

    private:

    int x_position_centre;
    int y_position_centre;
    int x_position_left;
    int x_position_right;
    int y_position_top;
    int y_position_bottom;
    bool moving_left = false;
    bool moving_right = false;
    

    public:

        Cursor(int x, int y){

            this->x_position_centre = x;
            this->y_position_centre = y;

            this->x_position_left = x_position_centre-32;
            this->x_position_right = x_position_centre+32;

            this->y_position_top = y - 8;
            this->y_position_bottom = y + 8;

        }

        int get_x_position_centre(){
            return x_position_centre;
        }

        void set_all_x(int new_value){
            x_position_centre = new_value;
            x_position_left = new_value-32;
            x_position_right = new_value+32;
        }

        void update_move_left(bool new_value){
            moving_left = new_value;
        }

        void update_move_right(bool new_value){
            moving_right = new_value;
        }

        void display_position(){

            glSprite(x_position_left, y_position_top,GL_FLIP_NONE,Area_Selector);

        }

        void movement(){
            //if cursor is on middle or right option, then can move left
            if ((moving_left==true) & ((x_position_centre == 128)|(x_position_centre == 198))){
                set_all_x(x_position_centre-70);
                moving_left = false;
            }

            //if cursor is on left or middle option, then can move right
            if ((moving_right==true) & ((x_position_centre == 58)|(x_position_centre == 128))){
                set_all_x(x_position_centre+70);
                moving_right = false;
            }

        }
        
};

//----------------------------------------wall class----------------------------------------//

class Wall{

private:

    int x_position_centre;
    int y_position_centre;
    int x_position_left;
    int x_position_right;
    int y_position_top;
    int y_position_bottom;


public:

    Wall(int x, int y, int width, int height){

        this->x_position_centre = x;
        this->y_position_centre = y;
        this->x_position_left = x_position_centre - (width/2);
        this->x_position_right = x_position_centre + (width/2);
        this->y_position_top = y_position_centre - (height/2);
        this->y_position_bottom = y_position_centre + (height/2);

    }


    int get_y_position_top(){
        return y_position_top;
    }

    int get_y_position_bottom(){
        return y_position_bottom;
    }

    int get_x_position_left(){
        return x_position_left;
    }

    int get_x_position_right(){
        return x_position_right;
    }


    void display_position(){

        glBegin2D();/*opens gl for 2d creation*/

        glBoxFilled(x_position_left,y_position_top,x_position_right,y_position_bottom,RGB15(0, 0, 255));

        glEnd2D();/*ends gl for 2d creation*/

    }


    bool detect_collision_player(Player player){
        bool contact = false;
        // if player's bottom is inside platform
        if ((player.get_x_position_left()<x_position_right)
            &(player.get_x_position_right()>x_position_left)){
                contact = true;
            }
        
        return contact;
    }

};

//----------------------------------------enemy class----------------------------------------//

class Enemy{


    private:

        int x_position_centre;
        int x_position_left;
        int x_position_right;
        int y_position_top;
        int y_position_bottom;
        int y_position_centre;
        int width;
        int height;
        bool moving = false;
        int GRAVITY = 7;
        int speed;
        bool jumping = true;
        bool falling = false;
        int velocity;
        int velocity_increment = 1;
        bool exist = true;
        int health;
        int damage;



    public:

        Enemy(int x,int y, int width, int height, int speed, int damage, int health){

            this->width = width;
            this->height = height;

            this->x_position_centre = x;
            this->x_position_left = x_position_centre - (width/2);
            this->x_position_right = x_position_centre + (width/2);
            

            this->y_position_centre = y;
            this->y_position_top = y-(height/2);
            this->y_position_bottom = y+(height/2);

            this->speed = speed;
            this->velocity = GRAVITY;

            this->damage = damage;
            this->health = health;

        }

        void update_all_y(int new_y){

            y_position_centre = new_y;
            y_position_top = new_y-(height/2);
            y_position_bottom = new_y+(height/2);

        }

        void update_all_x(int new_x){

            x_position_centre = new_x;
            x_position_left = x_position_centre - (width/2);
            x_position_right = x_position_centre + (width/2);

        }

        void movement_calculations(int frame, bool move_horizontally){

            if (frame%2 == 0){
                
                if (move_horizontally == true){
                    update_all_x(x_position_centre+speed);
                }
                

                if (jumping == true){
                    update_all_y(y_position_centre-velocity);
                    velocity -= velocity_increment;
                    //if jump hits peak then it is falling
                    if (velocity == 0){
                        jumping = false;
                        falling = true;
                    }
                }

                if (falling == true){
                    update_all_y(y_position_centre-velocity);
                    velocity -= velocity_increment;
                    if (velocity == -(GRAVITY)-1){
                        falling = false;
                        jumping = true;
                        velocity = GRAVITY;
                    }
                }
            }
            
        }

        void display_position(){

            glBegin2D();/*opens gl for 2d creation*/

            glSprite(x_position_left, y_position_top,GL_FLIP_NONE,Slime_Sprite);

            glEnd2D();/*ends gl for 2d creation*/

        }


        int get_x_position_centre(){
            return x_position_centre;
        }

        int get_x_position_left(){
            return x_position_left;
        }

        int get_x_position_right(){
            return x_position_right;
        }

        int get_y_position_centre(){
            return y_position_centre;
        }

        int get_y_position_top(){
            return y_position_top;
        }

        int get_y_position_bottom(){
            return y_position_bottom;
        }

        bool get_exist(){
            return exist;
        }

        int get_width(){
            return width;
        }

        int get_damage(){
            return damage;
        }

        void set_health(int new_value){
            health = new_value;
        }

        int get_health(){
            return health;
        }

        void set_exist(bool new_value){
            exist = new_value;
        }

        void set_all_x(int new_value){
            x_position_centre = new_value;
            x_position_left = new_value-16;
            x_position_right = new_value+16;
        }

};






class MetalBoss{

    private:

        int head_x_position_centre;
        int head_y_position_centre;

        int left_arm_x_position_centre;
        int left_arm_y_position_centre;

        int right_arm_x_position_centre;
        int right_arm_y_position_centre;

        bool left_arm_standby = true;
        bool right_arm_standby = true;

        bool left_arm_alive = true;
        bool right_arm_alive = true;

        bool boss_alive = true;

        int sprite_y = 32;

        int sprite_x = 32;


    public:

        MetalBoss(int head_x, int head_y, int left_x, int left_y, int right_x, int right_y){

            this->head_x_position_centre = head_x;
            this->head_y_position_centre = head_y;

            this->left_arm_x_position_centre = left_x;
            this->left_arm_y_position_centre = left_y;

            this->right_arm_x_position_centre = right_x;
            this->right_arm_y_position_centre = right_y;

        }


        void display_position(){

            glBegin2D();

            //head sprite

            glBoxFilled(head_x_position_centre-sprite_x,//x left
                        head_y_position_centre-sprite_y,//y top
                        head_x_position_centre+sprite_x,//x right
                        head_y_position_centre+sprite_y,//y bottom
                        RGB15(0, 0, 255));//colour

            //left arm sprite
            glBoxFilled(left_arm_x_position_centre-sprite_x,//x left
                        left_arm_y_position_centre-sprite_y,//y top
                        left_arm_x_position_centre+sprite_x,//x right
                        left_arm_y_position_centre+sprite_y,//y bottom
                        RGB15(0, 0, 255));//colour


            //right arm sprite
            glBoxFilled(right_arm_x_position_centre-sprite_x,//x left
                        right_arm_y_position_centre-sprite_y,//y top
                        right_arm_x_position_centre+sprite_x,//x right
                        right_arm_y_position_centre+sprite_y,//y bottom
                        RGB15(0, 0, 255));//colour

            glEnd2D();


        }


};





void Vblank() {
	frame++;
}


void new_screen_brightness_decrease(){
    //increase brightnes from 0 to -16 gradually
    int starting_brightness = 0;
    int time_delay = 1000000;
    int current_time;
    for (int i = 0; i<16; i++){
        setBrightness(1,starting_brightness);
        starting_brightness -= 1;
        current_time = 0;
        cpuStartTiming(0);
        while(current_time < time_delay){
            current_time = cpuGetTiming();
        }
        cpuEndTiming();
    }
    

}

void new_screen_brightness_increase(){
    //increase brightnes from -16 to 0 gradually
    int starting_brightness = -16;
    int time_delay = 1000000;
    int current_time;
    for (int i = 0; i<16; i++){
        setBrightness(1,starting_brightness);
        starting_brightness += 1;
        current_time = 0;
        cpuStartTiming(0);
        while(current_time < time_delay){
            current_time = cpuGetTiming();
        }
        cpuEndTiming();
    }
}



//----------------------------------------main menu method----------------------------------------//



int menu(){

    bool running = true;

    bool option_chosen = false;

    Cursor cursor(58,144);

    frame = 0;

    while(running){

        if (frame == 10){
            new_screen_brightness_increase();
        }

        scanKeys();

        if(keysDown() & KEY_A){
            option_chosen = true;
        }

        //check if left key is pressed

        if(keysDown() & KEY_LEFT){
            cursor.update_move_left(true);
        }


        if(keysUp() & KEY_LEFT){
            cursor.update_move_left(false);
        }

        //check if right key is pressed

        if(keysDown() & KEY_RIGHT){
            cursor.update_move_right(true);
        }


        if(keysUp() & KEY_RIGHT){
            cursor.update_move_right(false);
        }


        cursor.movement();//tries to move cursor

        glBegin2D();

        glSprite(0,0,GL_FLIP_NONE,Background_Main_Menu);

        glSprite(26, 136,GL_FLIP_NONE,Area_1_Button);//display area 1 button

        glSprite(96, 136,GL_FLIP_NONE,Area_2_Button);//display area 2 button

        glSprite(166, 136,GL_FLIP_NONE,Area_3_Button);//display area 3 button

        cursor.display_position();

        glEnd2D();

        glFlush(0);

        Vblank();

        swiWaitForVBlank();//wait for next frame

        if (option_chosen == true){
            running = false;
            new_screen_brightness_decrease();
        }

    }

    //get location of cursor and depending on what it is then return a different integer

    int cursor_location = cursor.get_x_position_centre();

    int choice;

    if (cursor_location == 58){
        choice = 1;
    }

    else if (cursor_location == 128){
        choice = 2;
    }

    else{
        choice = 3;
    }

    return choice;
}



//----------------------------------------bullet enemy collision method----------------------------------------//



bool projectile_enemy_collision(Projectile *projectile, Enemy *enemy){

    if ((((projectile)->get_x_position_left()) < ((enemy)->get_x_position_right()))&
    (((projectile)->get_x_position_left()) > ((enemy)->get_x_position_left()))&
    ((((projectile)->get_y_position_bottom() < (enemy)->get_y_position_bottom())&
    ((projectile)->get_y_position_bottom() >(enemy)->get_y_position_top()))|
    (((projectile)->get_y_position_top() < (enemy)->get_y_position_bottom())&
    ((projectile)->get_y_position_top() >(enemy)->get_y_position_top()))|
    (((projectile)->get_y_position_centre() < (enemy)->get_y_position_bottom())&
    ((projectile)->get_y_position_centre() >(enemy)->get_y_position_top())))){
        return true;
    }
    return false;
}



//----------------------------------------area 1 method----------------------------------------//



void area1(){

    Platform floor(128,188,256,20);

    Platform platform1(30,146,32,10);

    Platform platform2(226,146,30,10);

    Platform platform3(98,116,30,10);

    Platform platform4(158,116,30,10);

    char starting_direction = 'l';

    int starting_x = 176;

    int starting_y = 163;

    bool tracking_weapon_delay = false;

    bool tracking_reload = false;

    Player player(starting_x,starting_y,starting_direction);

    Wall left_wall(-7,96,10,192);

    Wall right_wall(262,96,10,192);

    //int projectile_speed, int damage, int projectile_delay, int reload_time, int direction_facing, int projectile_capacity, int x_position, int y_position

    Weapon weapon(10,10,10,100,'l',14,starting_x,starting_y+4,"ranged");

    //create lists for pointers to projectiles and enemies

    std::list<Projectile*> list_of_projectiles;

    std::list<Enemy*> list_of_enemies;

    std::list<MetalBoss*> boss_array;


    int health_of_base = 1000;

    int enemies_defeated = 0;

    int enemies_spawned = 0;

    frame = 0;

    bool running = true;

    bool area_failed = false;

    
	while(running) {





        if (frame == 10){
            //increase brightness to normal when entering area
            new_screen_brightness_increase();
        }

        

    

        //display sprites

        glBegin2D();

        glSprite(0, 0,GL_FLIP_NONE,Area_1_BG);

        glEnd2D();

        platform1.display_position();

        platform2.display_position();

        platform3.display_position();

        platform4.display_position();

        player.display_position();

        weapon.display_ammo_counter();

        glBegin2D();


        glBoxFilled(8,//x left
                    22,//y top
                    72,//x right
                    32,//y bottom
                    RGB15(0, 0, 255));//colour

        glEnd2D();

        



        //update projectile objects via pointer

        for(std::list<Projectile*>::iterator projectile_iterator = list_of_projectiles.begin(); projectile_iterator != list_of_projectiles.end();){

            (*projectile_iterator)->display_projectile();//show location
            (*projectile_iterator)->update_position();//move projectile

            iprintf("\n");
            iprintf("proj x %i",(*projectile_iterator)->get_x_position_centre());//print centre

            for(std::list<Enemy*>::iterator enemy_iterator = list_of_enemies.begin(); enemy_iterator != list_of_enemies.end();){

                //if projectile collides with an enemy
                if (projectile_enemy_collision(*projectile_iterator,*enemy_iterator)){
                    
                    (*projectile_iterator)->set_exist(false);//projectile no longer exists

                    (*enemy_iterator)->set_health((*enemy_iterator)->get_health()-(*projectile_iterator)->get_damage());//change health of enemy by damage of projectile

                    if((*projectile_iterator)->get_projectile_speed()<0){
                        (*enemy_iterator)->set_all_x((*enemy_iterator)->get_x_position_centre()-3);
                    }

                    else if (((*projectile_iterator)->get_projectile_speed()>0)&((*enemy_iterator)->get_x_position_centre()!=(256 - ((*enemy_iterator)->get_width())/2))){
                        (*enemy_iterator)->set_all_x((*enemy_iterator)->get_x_position_centre()+3);
                    }

                    if (((*enemy_iterator)->get_health()) <= 0){//if enemy health is less than 0, then it should no longer exist
                        (*enemy_iterator)->set_exist(false);
                    }
                }

                ++enemy_iterator;

            }

            //if projectile is not on screen, erase from list
            if(((*projectile_iterator)->get_exist())==false){
                projectile_iterator = list_of_projectiles.erase(projectile_iterator);
            }

            else{//else increment iterator
                ++projectile_iterator;
            }

        }

        //logic loop for existing enemies

        for(std::list<Enemy*>::iterator it = list_of_enemies.begin(); it != list_of_enemies.end();){

            iprintf("\n");
            iprintf("enemy health%i",(*it)->get_health());

            (*it)->display_position();//show location

            if ((*it)->get_x_position_centre() != 256 - ((*it)->get_width())/2){
                (*it)->movement_calculations(frame,true);//move projectile horizontally and vertically
            }

            else{
                (*it)->movement_calculations(frame,false);//move projectile only vertically
                health_of_base -= (*it)->get_damage();
            }

            if (((*it)->get_exist())==false){
                it = list_of_enemies.erase(it);
                enemies_defeated += 1;
            }
            else{
                ++it;
            }
            
        }





        //logic for boss

        for(std::list<MetalBoss*>::iterator it = boss_array.begin(); it != boss_array.end();){

            (*it)->display_position();//show location

            ++it;
            
        }




        
        //check what buttons are being pressed

        scanKeys();

        if(keysDown() & KEY_A){
            player.update_jump_action();
        }

        if(keysDown() & KEY_B){
            bool shooting = weapon.shoot_projectile();//handles delay and returns bool if shooting has occured
            if (shooting){
                //if weapon is shooting a new projectile, create a new pointer object and add to list of projectiles and track delay until next shot
                Projectile *new_projectile = weapon.create_projectile();
                list_of_projectiles.insert(list_of_projectiles.begin(), new_projectile);
                tracking_weapon_delay = true;
            }
            
        }

        if((keysDown() & KEY_LEFT)){
            player.update_move_left_action(true);
            player.set_sprite_frame(16);
            
        }

        if(keysUp() & KEY_LEFT){
            player.update_move_left_action(false);
            player.set_sprite_frame(5);
        }

        if((keysDown() & KEY_RIGHT)){
            player.update_move_right_action(true);
            player.set_sprite_frame(10);
        }

        if(keysUp() & KEY_RIGHT){
            player.update_move_right_action(false);
            player.set_sprite_frame(0);
        }

        if(keysDown() & KEY_START){
            area_failed = true;
        }

        if(keysDown() & KEY_R){
            if (weapon.get_current_projectile_amount() != 12){
                if (tracking_reload == false){
                    weapon.start_reload_timer();
                    tracking_reload = true;
                }
            }
            
        }





        //move player and weapon with player

        weapon.move_weapon(player.get_centre_x(),player.get_centre_y());

        player.character_movement();

        //update frames for player sprite animationm
        if (frame % 10 == 0){
            player.sprite_frame_update();
        }

        
        


        //checking if player can shoot another bullet via delay

        if(tracking_weapon_delay == true){
            weapon.update_time_until_next_projectile(weapon.get_time_until_next_projectile()-1);
            if (weapon.get_time_until_next_projectile() == 0){
                tracking_weapon_delay = false;
            }
        }


        //check to see if need to auto start_reload_timer due to empty magazine

        if(weapon.get_current_projectile_amount() == 0){
            if (tracking_reload == false){
                weapon.start_reload_timer();
                tracking_reload = true;
            }
        }


        //checking if tracking reload and if the reload is complete whilst updating reload timer

        if(tracking_reload == true){
            weapon.update_time_until_reloaded(weapon.get_time_until_reloaded()-1);
            if(weapon.get_time_until_reloaded() == 0){
                tracking_reload = false;
                weapon.reload_magazine();
            }
        }



        

        //collision detection for platforms

        //if on platform

        //if player's bottom is inside platform and if not jumping, set falling to false
        if (floor.detect_collision_player(player) == true){
            if(player.get_jumping() == false){
                player.set_falling(false);
                player.set_all_y(floor.get_y_position_top()-15);
                
            }
        }

        if (platform1.detect_collision_player(player) == true){
            if(player.get_jumping() == false){
                player.set_falling(false);
                player.set_all_y(platform1.get_y_position_top()-15);
                
            }
        }

        if (platform2.detect_collision_player(player) == true){
            if(player.get_jumping() == false){
                player.set_falling(false);
                player.set_all_y(platform2.get_y_position_top()-15);
                
            }
        }

        if (platform3.detect_collision_player(player) == true){
            if(player.get_jumping() == false){
                player.set_falling(false);
                player.set_all_y(platform3.get_y_position_top()-15);
                
            }
        }


        if (platform4.detect_collision_player(player) == true){
            if(player.get_jumping() == false){
                player.set_falling(false);
                player.set_all_y(platform4.get_y_position_top()-15);
                
            }
        }

        //if not on platform

        //if player's bottom is not inside platform and player is not jumping, set falling to true
        if ((floor.detect_collision_player(player) == false)
            &(platform1.detect_collision_player(player) == false)
            &(platform2.detect_collision_player(player) == false)
            &(platform3.detect_collision_player(player) == false)
            &(platform4.detect_collision_player(player) == false)){
                if(player.get_jumping() == false){
                    player.set_falling(true);
                }
        }





        //collision detection for walls

        if(left_wall.detect_collision_player(player)==true){
            player.set_all_x(left_wall.get_x_position_right()+player.get_hitbox_width()+1);
        }

        if(right_wall.detect_collision_player(player)==true){
            player.set_all_x(right_wall.get_x_position_left()-player.get_hitbox_width()-1);
        }





        //enemy spawning logic

        if (enemies_spawned < 10){

            if((frame%150 == 0)&(frame != 0)){

                //Enemy *new_enemy = new Enemy(-30,173,16,20,1,1,30);

                //list_of_enemies.insert(list_of_enemies.begin(),new_enemy);

                //enemies_spawned += 1;

            }
        }

        //boss spawning logic

        if ((enemies_defeated == 10)& (boss_array.size() == 0)){
            MetalBoss *boss = new MetalBoss(128,30,30,96,226,96);
            boss_array.insert(boss_array.begin(),boss);
        }
        
        //loss conditions

        if (health_of_base < 1){
            area_failed = true;
        }

        


        glFlush(0);

        Vblank();

        swiWaitForVBlank();//wait for next frame

        consoleClear();//clear bottom screen of text

        if (area_failed == true){
            running = false;
            new_screen_brightness_decrease();
        }

    }

}



//----------------------------------------area 2 method----------------------------------------//



void area2(){

    bool running = true;

    while(running){

        iprintf("Area 2");

        scanKeys();

        if(keysDown() & KEY_START){
            running = false;
        }

        glFlush(0);

        swiWaitForVBlank();//wait for next frame

        consoleClear();//clear bottom screen of text

    }

}



//----------------------------------------area 3 method----------------------------------------//



void area3(){

    bool running = true;

    while(running){

        iprintf("Area 3");

        scanKeys();

        if(keysDown() & KEY_START){
            running = false;
        }

        glFlush(0);

        swiWaitForVBlank();//wait for next frame

        consoleClear();//clear bottom screen of text

    }

}



//----------------------------------------main game loop method----------------------------------------//



int main(void) {

    videoSetMode(MODE_5_3D);//set video mode 

    glScreen2D();

    lcdMainOnTop(); //set main screen to top

    vramSetBankA( VRAM_A_TEXTURE );

    vramSetBankB( VRAM_B_TEXTURE );

    vramSetBankE(VRAM_E_TEX_PALETTE);

    LoadSprites();
    
    while(1){

        
        int cursor_location = menu();

        if (cursor_location == 1){
            area1();
        }

        else if (cursor_location == 2){
            area2();
        }

        else if (cursor_location == 3){
            area3();
        }

    }

	return 0;

}
